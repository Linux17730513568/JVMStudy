# 垃圾回收相关算法

## 一、判断阶段：对象存活判断

- 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。

- 那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。

- 判断对象存活一般有两种方式：==引用计数算法==和==可达性分析算法==。

### 1、引用计数算法

#### 1.1 概念

- 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型 的引用计数器属性。用于记录对象被引用的情况。

- 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

#### 1.2 优点

- 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

#### 1.3 缺点

- 需要单独的字段存储计数器，这样的做法增加了存储空间的开销。

- 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。

- 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一 条致命缺陷，导致==在Java的垃圾回收器中没有使用这类算法==。

  ![image-20210703094326043](https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703094326043.png)

#### 1.4 代码测试Java中没有使用引用计数算法

```java
/**
 * 代码测试Java中没有使用引用计数算法来判断对象是否为垃圾
 * VM参数：-XX:+PrintGCDetails
 */
public class RefCountGC {
    
    //故意占用空间10M
    byte data[] = new byte[1024 * 1024 * 10];

    private Object ref = null;

    public static void main(String[] args) {

        RefCountGC refCountGC1 = new RefCountGC();
        RefCountGC refCountGC2 = new RefCountGC();

        //循环引用
        refCountGC1.ref = refCountGC2;
        refCountGC2.ref = refCountGC1;

        refCountGC1 = null;
        refCountGC2 = null;

        //手动GC
        System.gc();
        
    }
}
```

- 手动GC关闭的时候，未执行GC，新生区占用used 25682K

![image-20210703101536496](https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703101536496.png)

- 手动执行GC打开，执行GC，新生区占用650K

  ![image-20210703101147058](https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703101147058.png)

说明执行GC之后，两个互相引用的对象被回收，说明Java使用的不是引用计数算法。

### 2、可达性分析算法/追踪性垃圾收集

- 相对于引用计数而言，可达性分析算法解决了循环引用的问题。防止了内存泄露的发生。
- 基本思路
  - 可达性分析算法是以根对象（GCRoots）为起始点，按照从上至下的方式==搜索被根对象集合所连接的目标对象是否可达。==
  
    ![image-20210703102423042](https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703102423042.png)
  
  - 使用可达性分析算法之后，内存中存活的对象都会被根对象集合直接或者间接连接，搜索走过的路径叫做==引用链==。
  
  - 如果目标对象没有任何引用链相连，则表示不可达，为垃圾。
  
  - 

## 二、对象的finalization机制

## 三、MAT与JProfiler的GCRoots溯源

## 四、清除阶段

### 1、标记清除算法

### 2、复制算法

### 3、标记压缩算法

### 4、分代收集算法

### 5、增量收集算法

### 6、分区算法

## 五、小结