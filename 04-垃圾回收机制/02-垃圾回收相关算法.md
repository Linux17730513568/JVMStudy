# 垃圾回收相关算法

## 一、判断阶段：对象存活判断

- 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。

- 那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。

- 判断对象存活一般有两种方式：==引用计数算法==和==可达性分析算法==。

### 1、引用计数算法

#### 1.1 概念 

- 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型 的引用计数器属性。用于记录对象被引用的情况。

- 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

#### 1.2 优点

- 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

#### 1.3 缺点

- 需要单独的字段存储计数器，这样的做法增加了存储空间的开销。

- 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。

- 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一 条致命缺陷，导致==在Java的垃圾回收器中没有使用这类算法==。

  ![image-20210703094326043](https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703094326043.png)

#### 1.4 代码测试Java中没有使用引用计数算法

```java
/**
 * 代码测试Java中没有使用引用计数算法来判断对象是否为垃圾
 * VM参数：-XX:+PrintGCDetails
 */
public class RefCountGC {
    
    //故意占用空间10M
    byte data[] = new byte[1024 * 1024 * 10];

    private Object ref = null;

    public static void main(String[] args) {

        RefCountGC refCountGC1 = new RefCountGC();
        RefCountGC refCountGC2 = new RefCountGC();

        //循环引用
        refCountGC1.ref = refCountGC2;
        refCountGC2.ref = refCountGC1;

        refCountGC1 = null;
        refCountGC2 = null;

        //手动GC
        System.gc();
        
    }
}
```

- 手动GC关闭的时候，未执行GC，新生区占用used 25682K

![image-20210703101536496](https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703101536496.png)

- 手动执行GC打开，执行GC，新生区占用650K

  ![image-20210703101147058](https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703101147058.png)

说明执行GC之后，两个互相引用的对象被回收，说明Java使用的不是引用计数算法。

### 2、可达性分析算法/追踪性垃圾收集

- 相对于引用计数而言，可达性分析算法解决了循环引用的问题。防止了内存泄露的发生。

- #### 基本思路
  
  - 可达性分析算法是以根对象（GCRoots）为起始点，按照从上至下的方式==搜索被根对象集合所连接的目标对象是否可达。==
  
    ![image-20210703102423042](https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703102423042.png)
  
  - 使用可达性分析算法之后，内存中存活的对象都会被根对象集合直接或者间接连接，搜索走过的路径叫做==引用链==。
  
  - 如果目标对象没有任何引用链相连，则表示不可达，为垃圾。
  
- #### Java语言中，GCRoots链包括以下几类元素

  - 各个线程被调用的方法中的参数，局部变量
  - 本地方法栈内JNT（本地方法）引用的对象
  - 方法区中静态属性引用的对象
    - 比如： Java类中引用类型静态变量
  - 方法区中的常量引用的对象
    - 比如字符串常量池的引用
  - 所有被同步锁持有的对象
  - 虚拟机的内部引用
    - 基本数据类型的包装类，常驻的异常对象，系统类加载器
  - 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
  - 除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）。 
  - 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针 对新生代），
    必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，
    这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一.并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。

- 小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。

  ![image-20210703205542925](https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703205542925.png)

  **注意**

  - 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。

  - 这点也是导致GC进行时必须“StopTheWorld"的一个重要原因。
    - ➢即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

## 二、对象的finalization机制

- Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
- 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize（）方法。
- finalize（）方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。
- 永远不要主动调用某个对象的finalize （）方法，应该交给垃圾回收机制调用。理由包括下面三点：
  - ➢在finalize()时可能会导致对象复活。
  - ➢finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。
  - ➢一个糟糕的finalize （）会严重影响GC的性能。
- 从功能上来说，finalize（）方法与C++ 中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质，上不同于C++ 中的析构函数。

### 1.对象是否"死亡

- 由于finalize （）方法的存在，==虚拟机中的对象一般处于三种可能的状态。==
- 如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。==一个无法触及的对象有可能在某一个条件下“复活”自己==，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：
  - ➢==可触及的==：从根节点开始，可以到达这个对象。
  - ➢==可复活的==：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。
  - ➢==不可触及的==：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize（） 只会被调用一一次。
- 以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。

### 2.**判定是否可以回收具体过程**

如果对象objA到GC Roots没有引用链，则进行第一 次标记。

进行筛选，判断此对象是否有必要执行finalize（）方法

1. ①如果对 象objA没有重写finalize（）方法，或者finalize （）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
2. ②如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F一Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。
3. ③finalize（）方法是对象逃脱死亡的最后机会，稍后Gc会对F一Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。
   在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。

### 3.代码测试对象复活

```java
/**
 * 测试Object类中finalize()方法
 */
public class CanReliveObject {

    public static CanReliveObject ref;

    @Override
    protected void finalize() throws Throwable {
        System.out.println("调用当前类重写的finalize()方法");
        //当前待回收的对象重新加入引用链
        ref = this;
    }

    public static void main(String[] args) {

        ref = new CanReliveObject();

        ref = null;
        //调用垃圾回收
        System.gc();
        System.out.println("第一次GC执行完毕");

        /**
         * 因为finalize优先级较低 主线程暂停2s 等待它
         */
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if(ref == null){
            System.out.println("对象已死");
        }else {
            System.out.println("对象未死");
        }
        ref = null;
        System.gc();
        System.out.println("第二次GC执行完毕");
        if(ref == null){
            System.out.println("对象已死");
        }else {
            System.out.println("对象未死");
        }
    }

}
```

引用对象ref刚开始指向一个对象，==此时为可触及状态==然后让他指向null，==此时为可复活状态==手动调用GC，此时处于会回调执行重写的finalize方法，方法中给这个引用重新赋值了，所以此时为==可触及状态==

再次指向NULL，此时为==不可触及状态==（finalize方法只执一次），所以对象此时已经死了。

#### 结果：

```
第一次GC执行完毕
调用当前类重写的finalize()方法
对象未死
第二次GC执行完毕
对象已死
```

## 三、MAT与JProfiler的GCRoots溯源



## 四、清除阶段

### 1、标记清除算法

### 2、复制算法

### 3、标记压缩算法

### 4、分代收集算法

### 5、增量收集算法

### 6、分区算法

## 五、小结